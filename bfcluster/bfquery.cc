#include "bfquery.h"#include <tclap/CmdLine.h>BFQuery::BFQuery(double threshold)// threshold = 0.9 by default{    QUERY_THRESHOLD = threshold;    if(enable_debug){        std::cerr << "[BFQuery] query threshold: " << QUERY_THRESHOLD << std::endl;    }}BFQuery::~BFQuery(){    if(bt_root != NULL){        delete bt_root;    }    if(hash_pair != NULL){        delete hash_pair;    }    if(query_state_set.size() > 0){        // delete the query states        for (auto & q_state : query_state_set) {            if(q_state != NULL){                delete q_state;                q_state = NULL;            }        }        query_state_set.clear();    }else{        for(auto q: query_info_set){            if(q != NULL){                delete q;                q = NULL;            }        }    }    matching_table.clear();}void BFQuery::BatchQuery(BloomTree* root, RoarQuerySet & qs, bool heuristic_match){    bool has_children = root->child(0) || root->child(1);    RoarQuerySet pass;    unsigned n = 0;    for(auto & q: qs){        bool query_passed;        q->nodes_visited++;        if(heuristic_match){            query_passed = HeuristicQueryPass(root, q);        }else{            query_passed = QueryPass(root, q);        }        if(query_passed){            if(has_children){                pass.emplace_back(q);            }else{                q->matching.emplace_back(root);                n++;            }        }    }    if(pass.size() > 0){        if(root->child(0)){            BatchQuery(root->child(0), pass, heuristic_match);        }        if(root->child(1)){            BatchQuery(root->child(1), pass, heuristic_match);        }    }}void BFQuery::BatchQueryFromFile(const std::string& bloomtree_filename,                         const std::string& query_filename,                         const std::string& hash_filename,                        const std::string& output_filename,                        bool heuristic_match)//{    hash_pair = get_hash_function(hash_filename, number_of_hashes);    bt_root = read_bloom_tree(bloomtree_filename);    auto bf = dynamic_cast<RoarBF*>(bt_root->bf());    bf_size = bf->num_filter_bits();    query_sequence_list = ReadQueries(query_filename);    for(std::string query_sequence: query_sequence_list){        query_info_set.emplace_back(new RoarQueryInfo(query_sequence, *hash_pair, number_of_hashes, bf_size, heuristic_match));    }    if(heuristic_match){        std::cout << "Perform Heuristic Batch Query..." << std::endl;    }        if(bt_root->is_split()){        SplitBatchQueryStart(bt_root, query_info_set, heuristic_match);        std::ofstream out(output_filename);        PrintQueryStateSet(query_state_set, out);        out.close();    }    else{        BatchQuery(bt_root, query_info_set, heuristic_match);        std::ofstream out(output_filename);        PrintQuerySet(query_info_set, out);        out.close();    }    // query_info_set will be cleared in destructor}int BFQuery::CheckBfSize(std::string bf_filename, HashPair hp, int nh)//----// CheckBfSize//	pick a bloom filter file and return its bit vector size	//----// Parameters://	std::string		bf_filename		bloom filter file name//	HashPair		hp 				hash file used to generate this bloom filter//	int 			nh				number of hash functions//									hp and nh can be generated from hp = get_hash_function(hashfunction_filename, nh);{		UncompressedBF * bf = new UncompressedBF(bf_filename, hp, nh, 0);	if(bf == NULL) return -1;	bf->load();	int result = bf->bv->size();	delete bf; 	return result;}int BFQuery::CheckRoarBfSize(std::string bf_filename, HashPair hp, int nh)//----// CheckBfSize//	pick a bloom filter file and return its bit vector size	//----// Parameters://	std::string		bf_filename		bloom filter file name//	HashPair		hp 				hash file used to generate this bloom filter//	int 			nh				number of hash functions//									hp and nh can be generated from hp = get_hash_function(hashfunction_filename, nh);{		RoarBF *bf = new RoarBF(bf_filename, hp, nh, 0);	if(bf == NULL) return -1;	bf->load();	int result = bf->num_filter_bits();	delete bf; 	return result;}void BFQuery::ExperimentQueryFromFile(const std::string& bloomtree_filename,                         const std::string& query_filename,                         const std::string& hash_filename,                        const std::string& output_filename,                        bool heuristic_match)//{    hash_pair = get_hash_function(hash_filename, number_of_hashes);    bt_root = read_bloom_tree(bloomtree_filename);    auto bf = dynamic_cast<RoarBF*>(bt_root->bf());    bf_size = bf->num_filter_bits();        query_info_set.emplace_back(ReadExperiment(query_filename, hash_pair, number_of_hashes, bf_size, heuristic_match));    if(heuristic_match){        std::cout << "Perform Heuristic Experiment Query..." << std::endl;    }        if(bt_root->is_split()){        SplitBatchQueryStart(bt_root, query_info_set, heuristic_match);        std::ofstream out(output_filename);        PrintQueryStateSet(query_state_set, out);        out.close();    }    else{        BatchQuery(bt_root, query_info_set, heuristic_match);        std::ofstream out(output_filename);        PrintQuerySet(query_info_set, out);        out.close();    }}int BFQuery::HeuristicQuery(BloomTree* root, RoarQueryInfo* q){    int nodes_visited = 1;    root->increment_usage();    if(HeuristicQueryPass(root, q)){        int children = 0;        if(root->child(0)){            nodes_visited += HeuristicQuery(root->child(0), q);            children++;        }        if(root->child(1)){            nodes_visited += HeuristicQuery(root->child(1), q);            children++;        }        // leaf hit        if(children == 0){            q->matching.push_back(root);        }    }    return nodes_visited;}bool BFQuery::HeuristicQueryPass(BloomTree* root, RoarQueryInfo* q){    RoarBF* ref_bf = dynamic_cast<RoarBF*>(root->bf());     RoarBF* intersect_bf = dynamic_cast<RoarBF*>(ref_bf->intersection_with("tmp.interset.bf.bv.roar", q->roarbf));    int counts = intersect_bf->count_ones();    delete intersect_bf;    return (counts >= QUERY_THRESHOLD * q->ones_number);}int BFQuery::Query(BloomTree* root, RoarQueryInfo* q)//----// Query//  recursively walk down the tree, preceeding to children only//  if their parent passes the query threshold//----// Parameters//  BloomTree*              root    bloom subtree root//  RoarBF*                 roarbf  RoarBF converted from query fasta//  vector<BloomTree*>      out     matched leaves list//----// Code Reviewed{    int nodes_visited = 1;    root->increment_usage();    if(QueryPass(root, q)){        int children = 0;        if(root->child(0)){            nodes_visited += Query(root->child(0), q);            children++;        }        if(root->child(1)){            nodes_visited += Query(root->child(1), q);            children++;        }        // leaf hit        if(children == 0){            q->matching.push_back(root);        }    }    return nodes_visited;}int BFQuery::Query(BloomTree* root, RoarBF* roarbf, std::vector<BloomTree*> & out)//----// Query//  recursively walk down the tree, preceeding to children only//  if their parent passes the query threshold//----// Parameters//  BloomTree*              root    bloom subtree root//  RoarBF*                 roarbf  RoarBF converted from query fasta//  vector<BloomTree*>      out     matched leaves list{    int nodes_visited = 1;    root->increment_usage();    if(QueryPass(root, roarbf)){        int children = 0;        if(root->child(0)){            nodes_visited += Query(root->child(0), roarbf, out);            children++;        }        if(root->child(1)){            nodes_visited += Query(root->child(1), roarbf, out);            children++;        }        // leaf hit        if(children == 0){            out.push_back(root);        }    }    return nodes_visited;}bool BFQuery::QueryPass(BloomTree* root, RoarBF * roarbf)//----// QueryPass//  can only perform heuristic query with threshold//----{    if(enable_debug){        std::cout << "[BFQuery] Warning: directly search with RoarBF perform heuristic search with threshold." << std::endl;    }    RoarBF* ref_bf = dynamic_cast<RoarBF*>(root->bf()); 	// because of cache system of BloomTree, no need to delete ref_bf?	// root->bf call load(), and load() returns according to file suffix.    RoarBF* intersect_bf = dynamic_cast<RoarBF*>(ref_bf->intersection_with("", roarbf));    int counts = intersect_bf->count_ones();    delete intersect_bf;    return (counts >= QUERY_THRESHOLD * (int)roarbf->count_ones());}bool BFQuery::QueryPass(BloomTree* root, RoarQueryInfo* q)//----// QueryPass//  can perform exact query with threshold//  use a hashtable `multiple_hits`, store all pos in bloom filter that has multiple hits//  count = intersect bloom filter. count_ones()//  iterate each postion P of multiple_hits//  if the value of intersect bloom filter at position P is 1, then count += (multiple_hits[P]-1)//----// Paramters  //  Bloomtree*           root//  RoarQueryInfo*       q//----// Code Reviewed{    RoarBF* ref_bf = dynamic_cast<RoarBF*>(root->bf());     // because of cache system of BloomTree, no need to delete ref_bf?    // root->bf call load(), and load() returns according to file suffix.    //if(enable_debug){    //    std::cerr << "before intersection: " << ref_bf->count_ones() << "," << q->roarbf->count_ones() << std::endl;    //}    RoarBF* intersect_bf = dynamic_cast<RoarBF*>(ref_bf->intersection_with("tmp.intersect.bf.bv.roar", q->roarbf));    int counts = intersect_bf->count_ones();    for(auto it = q->multiple_hits.begin(); it != q->multiple_hits.end(); it++){        const size_t pos = it->first;        if(intersect_bf->operator[](pos) == 1){            counts += it->second - 1;        }    }    delete intersect_bf;    int pass_threshold = QUERY_THRESHOLD * q->kmer_number;    if(enable_debug){        std::cerr << "threshold " << QUERY_THRESHOLD << std::endl;        std::cerr << "counts " << counts << ", " << "pass_number " << pass_threshold << std::endl;    }    return (counts >= pass_threshold);}//----batch queryingstd::vector<std::string> BFQuery::ReadQueries(std::string query_filename)//----// ReadQueries//	//----// Code Reviewed{    std::vector<std::string> result;     std::ifstream input(query_filename);    if(!input.good()){        std::cerr << "Error: [BFQuery] error opening '"<<query_filename<<"'. Bailing out." << std::endl;        return result;    }    if(enable_debug){    	std::cout << "[BFQuery]----reading query list from file " << query_filename << std::endl;    }    std::string line;    while(std::getline(input, line).good()){    	if(!line.empty()){    		if(line[0] != '>'){    			result.push_back(line);    		}    		//if(enable_debug){    		//	std::cout << line << std::endl;    		//}    	}    }    if(enable_debug){    	std::cout << "[BFQuery]----finish reading query list" << std::endl;    }    if(result.size() == 0){    	std::cerr << "Error: [BFQuery] empty valid query " << std::endl;    	return result;    }    return result;}RoarQueryInfo* BFQuery::ReadExperiment(std::string query_filename,                                     HashPair* hash_pair,                                     int number_of_hashes,                                     uint64_t bf_size,                                     bool heuristic_match){    RoarQueryInfo* q = new RoarQueryInfo("", *hash_pair, number_of_hashes, bf_size, heuristic_match);    std::ifstream input(query_filename);    if(!input.good()){        std::cerr << "Error: [BFQuery] error opening '"<<query_filename<<"'. Bailing out." << std::endl;        if(q){            delete q;        }        return NULL;    }    if(enable_debug){        std::cout << "[BFQuery]----reading experiment reads from file " << query_filename << std::endl;    }    std::string line;    while(std::getline(input, line).good()){        if(!line.empty()){            if(line[0] != '>'){                q->InsertSequence(line, *hash_pair, number_of_hashes, bf_size, heuristic_match);            }        }    }    //It's very important to set right ones_number on your own    if(heuristic_match){        q->ones_number = (int)(q->roarbf->count_ones());     }    //if(enable_debug){    //    q->CheckKmer(heuristic_match);    //}    q->query = "Experiment:"+query_filename;    return q;    // caller is responsible for delete q}void BFQuery::PrintQueryInfo(RoarQueryInfo* q, std::ostream & out){    out << "*" << q->query << " " << q->matching.size() << std::endl;    out << "# " << q->nodes_visited << " nodes visited" << std::endl;    for (const auto& n : q->matching) {        out << n->name() << std::endl;    }}void BFQuery::PrintQuerySet(const RoarQuerySet & qs, std::ostream & out)//----// PrintQuerySet//----{    for (auto& q : qs) {        if(q->matching_closed){            std::cerr << "[BFQuery] Warning: output intermedia query matching information!" << std::endl;        }        out << "*" << q->query << " " << q->matching.size() << std::endl;        out << "# " << q->nodes_visited << " nodes visited" << std::endl;        for (const auto& n : q->matching) {            out << n->name() << std::endl;        }    }}void BFQuery::PrintQueryStateSet(const RoarQueryStateSet & q_state_s, std::ostream & out)//----// PrintQueryStateSet//----{    //assert (q_state_s.size() == matching_table.size());    for (int i = 0; i < (int)(q_state_s.size()); i++) {        auto q_state = q_state_s[i];        out << "*" << q_state->q->query << " ";        if(matching_table.find(i) != matching_table.end()){            out << matching_table[i].size() << std::endl;            for (const auto& n : matching_table[i]) {                out << n->name() << std::endl;            }        }else{            out << "0" << std::endl;        }    }}void BFQuery::SequentialQuery(const std::string& bloomtree_filename,     const std::string& query_filename,     const std::string& hash_filename,    const std::string& output_filename,    bool heuristic_match)//----// BatchQuery//----// Code Reviewed{    hash_pair = get_hash_function(hash_filename, number_of_hashes);    bt_root = read_bloom_tree(bloomtree_filename);    auto bf = dynamic_cast<RoarBF*>(bt_root->bf());    bf_size = bf->num_filter_bits();    query_sequence_list = ReadQueries(query_filename);    std::ofstream out(output_filename);    if(heuristic_match){        std::cout << "Perform Heuristic Query..." << std::endl;    }        for(std::string query_sequence : query_sequence_list){        RoarQueryInfo * rqi = new RoarQueryInfo(query_sequence, *hash_pair, number_of_hashes, bf_size, heuristic_match);        if(heuristic_match){            HeuristicQuery(bt_root, rqi);        }else{            Query(bt_root, rqi);        }        rqi->ClearBf();        PrintQueryInfo(rqi, out);        delete rqi;    }    out.close();}//----split queryvoid BFQuery::SplitBatchQueryAllLeavesMatch(BloomTree* root, int q_state_id){    bool has_children = root->child(0) || root->child(1);    if (has_children) {        if (root->child(0)) SplitBatchQueryAllLeavesMatch(root->child(0), q_state_id);        if (root->child(1)) SplitBatchQueryAllLeavesMatch(root->child(1), q_state_id);    } else {        matching_table[q_state_id].emplace_back(root);    }}void BFQuery::SplitBatchQuery(BloomTree* root, RoarQueryStateSet active_queries, bool heuristic_match){	//std::cerr << "---start " << root->name() << std::endl;	bool has_children = root->child(0) || root->child(1);    split_batch_query_count ++;    RoarQueryStateSet undetermined;    auto all_bf = dynamic_cast<RoarBF*>(root->bf_all());    auto some_bf = dynamic_cast<RoarBF*>(root->bf());    unsigned n = 0;    for(auto & q_state: active_queries){        RoarQueryState* child_q_state = q_state->QueryAllsomeNode(all_bf, some_bf, heuristic_match);        // child_q_state has the same id as q_state        //      new RoarQueryInfo with roarbf as the intersection of q_state->q->roarbf with some_bf        //      new multiple_hits corresponding to new roarbf        //      new num_passed and num_failed calculated according to root        if(child_q_state->num_passed >= child_q_state->pass_thresh){            // you can also directly check if child_q_state->q == NULL            assert(child_q_state->q == NULL);            //only id is needed            int q_state_id = child_q_state->id;            delete child_q_state;            if(has_children){                if(root->child(0)) SplitBatchQueryAllLeavesMatch(root->child(0), q_state_id);                if(root->child(1)) SplitBatchQueryAllLeavesMatch(root->child(1), q_state_id);            }else{                matching_table[q_state_id].emplace_back(root);                n++;            }        }else if(child_q_state->num_failed > child_q_state->fail_thresh){            delete child_q_state;        }else if(has_children){            undetermined.emplace_back(child_q_state);        }    }    if (has_children) {        std::cout << "[search " << split_batch_query_count << "] " << root->name() << " internal " << undetermined.size() << "/" << active_queries.size() << std::endl;    } else {        std::cout << "[search " << split_batch_query_count << "] " << root->name() << " leaf "     << n                   << "/" << active_queries.size() << std::endl;    }    if (undetermined.size() > 0) {		// if present, recurse into left child        if (root->child(0)) {            SplitBatchQuery(root->child(0), undetermined, heuristic_match);        }        // if present, recurse into right child        if (root->child(1)) {            SplitBatchQuery(root->child(1), undetermined, heuristic_match);        }    	for (auto & q_state : undetermined) {        	if(q_state != NULL){                delete q_state;                q_state = NULL;            }    	}    }	//std::cerr << "----end " << root->name() << std::endl;}void BFQuery::SplitBatchQueryStart(BloomTree* root, RoarQuerySet & qs, bool heuristic_match){    // construct a state for each query, reducing kmers to bf-positions    //std::cerr << "SplitBatchQueryStart" << std::endl;    int i = 0;	for (auto & q : qs) {                int total_number = q->ones_number;        if(!heuristic_match){            total_number = q->kmer_number;            q->CreateRepeatBF(*hash_pair, number_of_hashes, bf_size, heuristic_match);        }                unsigned pass_thresh = ceil(QUERY_THRESHOLD * total_number);        unsigned fail_thresh = total_number - pass_thresh;        RoarQueryState* q_state = new RoarQueryState(q, pass_thresh, fail_thresh);        q_state->id = i;        i++;		query_state_set.emplace_back(q_state);        //DEBUG:        //std::cerr << "query to bf positions" << std::endl;        //std::cerr << q->query << std::endl;        //dump_positions(q_state->kmer_positions);    }    // perform the queries    split_batch_query_count = 0;    SplitBatchQuery(root, query_state_set, heuristic_match); }typedef struct Args {    std::string bloomtree_filename;    std::string query_filename;    std::string hash_filename;    std::string output_filename;    double matching_threshold;    bool heuristic_match;    bool multiple_match;    bool enable_debug;}Args;bool TclapParser(Args & args, int argc, char** argv){    std::string version = "0.9";    try {        std::string desc = "squery \n";        TCLAP::CmdLine cmd(desc, ' ', version);        TCLAP::ValueArg<std::string> arg_hash_filename("f", "hashfile", "hash file", true, "", "file");        TCLAP::ValueArg<std::string> arg_bloomtree_filename("b", "bloomtree", "bloom tree topology file", true, "", "file");        TCLAP::ValueArg<std::string> arg_query_filename("q", "query", "query FASTA file", true, "", "file");        //TCLAP::ValueArg<std::string> arg_output_dir("d", "output_dir", "output directory, default is current working directory", false, ".", "string");        TCLAP::ValueArg<std::string> arg_output_filename("o", "output", "output file", true, "", "file");        TCLAP::ValueArg<double> arg_matching_threshold("t", "threshold", "matching threshold (default=0.9)", false, 0.9, "double");                TCLAP::SwitchArg arg_enable_debug("d", "debug", "output debug information", cmd, false);        TCLAP::SwitchArg arg_heuristic_match("E", "exact_match", "calculate exact number of matching kmers (defaultly not)", cmd, true);        TCLAP::SwitchArg arg_multiple_match("m", "multiple_match", "consider entries in FASTA file separately (defaultly consider all kmers as one query)", cmd, false);        cmd.add(arg_matching_threshold);        cmd.add(arg_output_filename);        //cmd.add(arg_output_dir);        cmd.add(arg_query_filename);        cmd.add(arg_hash_filename);        cmd.add(arg_bloomtree_filename);        cmd.parse(argc, argv);        args.bloomtree_filename = arg_bloomtree_filename.getValue();        args.hash_filename = arg_hash_filename.getValue();        args.query_filename = arg_query_filename.getValue();        args.output_filename = arg_output_filename.getValue();        args.matching_threshold = arg_matching_threshold.getValue();        args.heuristic_match = arg_heuristic_match.getValue();        args.enable_debug = arg_enable_debug.getValue();        args.multiple_match = arg_multiple_match.getValue();    }    catch (TCLAP::ArgException &e)    {        std::cerr << "error: " << e.error() << " for arg " << e.argId() << "\n";        abort();    }    return true;}void file_exists (const std::string& filename) {    struct stat buffer;       if (stat (filename.c_str(), &buffer) != 0)         printf( "cannot access %s\n", filename.c_str() );}void dir_exists(const std::string& pathname){    struct stat info;    if( stat( pathname.c_str(), &info ) != 0 )        printf( "cannot access %s\n", pathname.c_str() );    else if(! (info.st_mode & S_IFDIR))         printf( "%s is no directory\n", pathname.c_str() );}int main(int argc, char* argv[]){    BloomTree::caching = true;        Args args;    TclapParser(args, argc, argv);    file_exists(args.bloomtree_filename);    file_exists(args.hash_filename);    file_exists(args.query_filename);    BFQuery* bfq = new BFQuery(args.matching_threshold);    if(args.multiple_match){        bfq->BatchQueryFromFile(args.bloomtree_filename,                     args.query_filename,                     args.hash_filename,                    args.output_filename,                    args.heuristic_match);    }else{        //if(args.heuristic_match == false){        //    std::cerr<<"[squery] Warning: can Not perform exact query with large query support." << std::endl;        //    std::cerr<<"[squery] Warning: automatically perform heuristic query with large query support." << std::endl;        //}        bfq->ExperimentQueryFromFile(args.bloomtree_filename,                     args.query_filename,                     args.hash_filename,                    args.output_filename,                    args.heuristic_match);    }    delete bfq;    return 0;}